package io.github.gbessonov.jhash.implementations.murmur3f;


import io.github.gbessonov.jhash.HashCode;

import java.math.BigInteger;

/**
 * Represents a 128-bit hash code generated by the Murmur3F hashing algorithm.
 * This implementation stores the hash as two 64-bit {@code long} values and provides
 * various utility methods for accessing the hash in different formats.
 * <p>
 * The class is immutable and thread-safe.
 */
class Murmur3fHashCode implements HashCode {
    private final long h1;
    private final long h2;

    /**
     * Constructs a new {@code Murmur3fHashCode} from two 64-bit parts of a 128-bit hash.
     *
     * @param h1 the low 64 bits of the hash
     * @param h2 the high 64 bits of the hash
     */
    public Murmur3fHashCode(long h1, long h2) {
        this.h1 = h1;
        this.h2 = h2;
    }

    /**
     * Returns the 128-bit hash code as a 16-byte array in big-endian order.
     * The high 64 bits (h2) come first, followed by the low 64 bits (h1).
     *
     * @return a 16-byte array in big-endian order
     */
    @Override
    public byte[] getValueBytesBigEndian() {
        byte[] bytes = new byte[16];
        for (int i = 0; i < 8; i++) {
            bytes[i] = (byte) ((h2 >>> (56 - i * 8)) & 0xff);
        }
        for (int i = 0; i < 8; i++) {
            bytes[8 + i] = (byte) ((h1 >>> (56 - i * 8)) & 0xff);
        }
        return bytes;
    }

    /**
     * Returns the 128-bit hash code as a 16-byte array in little-endian order.
     * The low 64 bits (h1) come first, followed by the high 64 bits (h2).
     *
     * @return a 16-byte array in little-endian order
     */
    public byte[] getValueBytesLittleEndian() {
        byte[] bytes = new byte[16];
        for (int i = 0; i < 8; i++) {
            bytes[i] = (byte) ((h1 >>> (i * 8)) & 0xff);
        }
        for (int i = 0; i < 8; i++) {
            bytes[8 + i] = (byte) ((h2 >>> (i * 8)) & 0xff);
        }
        return bytes;
    }

    /**
     * Returns the 128-bit hash code as a positive {@link BigInteger}.
     * This uses the big-endian byte representation of the hash.
     *
     * @return a positive BigInteger representing the hash code
     */
    @Override
    public BigInteger getValueBigInteger() {
        byte[] bytes = getValueBytesBigEndian();
        return new BigInteger(1, bytes);
    }

    /**
     * Returns the 128-bit hash code as a zero-padded hexadecimal string.
     * The string consists of 32 hexadecimal digits.
     *
     * @return a 32-character hexadecimal string representation of the hash
     */
    public String getValueHexString() {
        return getPaddedHexString(h2) + getPaddedHexString(h1);
    }

    private String getPaddedHexString(long value) {
        StringBuilder string = new StringBuilder(Long.toHexString(value));
        while (string.length() < 16) {
            string.insert(0, '0');
        }
        return string.toString();
    }

    @Override
    public String toString() {
        return "HashCode.Murmur3F: " + getValueHexString();
    }

    @Override
    public int hashCode() {
        return Long.hashCode(h1) * 17 + Long.hashCode(h2);
    }

    @Override
    public boolean equals(Object other) {
        if (other instanceof Murmur3fHashCode otherMurmur3fHashCode) {
            return h1 == otherMurmur3fHashCode.h1 && h2 == otherMurmur3fHashCode.h2;
        }
        return false;
    }
}
